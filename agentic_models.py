"""
Database models for Agentic AI Investment Advisory System
Extends the existing database schema with AI agent functionality
"""

from datetime import datetime
from sqlalchemy import Column, Integer, String, Float, Boolean, Text, DateTime, ForeignKey
from sqlalchemy.types import JSON  # Use this instead of PostgreSQL-specific JSON
from sqlalchemy.orm import relationship
from typing import Dict  # Add this import

# Import your existing db instance when needed
# from app import db

# For integration, use the db instance passed from main app
db = None  # This will be set during initialization

class InvestmentAgent(db.Model):
    """AI Agent model for autonomous investment advisory"""
    __tablename__ = 'investment_agents'
    
    id = Column(Integer, primary_key=True)
    investor_id = Column(String(50), nullable=False, index=True)
    agent_name = Column(String(100), default='AI Investment Advisor')
    
    # Agent Configuration
    config = Column(JSON, default={})  # Stores agent parameters as JSON
    
    # Performance Metrics
    total_recommendations = Column(Integer, default=0)
    successful_recommendations = Column(Integer, default=0)
    accuracy_rate = Column(Float, default=0.0)
    total_return = Column(Float, default=0.0)
    
    # Agent State
    is_active = Column(Boolean, default=True)
    last_analysis_time = Column(DateTime)
    last_learning_update = Column(DateTime)
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationships
    actions = relationship('AgentAction', back_populates='agent', lazy='dynamic')
    recommendations = relationship('AgentRecommendation', back_populates='agent', lazy='dynamic')
    learning_data = relationship('AgentLearning', back_populates='agent', lazy='dynamic')
    
    def __repr__(self):
        return f'<InvestmentAgent {self.agent_name} for investor {self.investor_id}>'
    
    def to_dict(self):
        return {
            'id': self.id,
            'investor_id': self.investor_id,
            'agent_name': self.agent_name,
            'config': self.config,
            'accuracy_rate': self.accuracy_rate,
            'total_recommendations': self.total_recommendations,
            'successful_recommendations': self.successful_recommendations,
            'total_return': self.total_return,
            'is_active': self.is_active,
            'last_analysis_time': self.last_analysis_time,
            'created_at': self.created_at
        }


class AgentAction(db.Model):
    """Actions taken by AI agents"""
    __tablename__ = 'agent_actions'
    
    id = Column(Integer, primary_key=True)
    agent_id = Column(Integer, ForeignKey('investment_agents.id'), nullable=False)
    
    # Action Details
    action_type = Column(String(50), nullable=False)  # 'recommendation', 'alert', 'analysis', etc.
    ticker = Column(String(20))
    action_data = Column(JSON)  # Detailed action information
    
    # Execution Details
    confidence_score = Column(Float)
    risk_level = Column(String(20))  # 'LOW', 'MEDIUM', 'HIGH'
    expected_return = Column(Float)
    
    # Outcome Tracking
    execution_status = Column(String(20), default='pending')  # 'pending', 'executed', 'failed'
    outcome_measured = Column(Boolean, default=False)
    actual_return = Column(Float)
    success = Column(Boolean)
    
    # Context
    market_context = Column(JSON)  # Market conditions at time of action
    research_report_id = Column(String(50))  # Link to research report if applicable
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)
    executed_at = Column(DateTime)
    outcome_measured_at = Column(DateTime)
    
    # Relationships
    agent = relationship('InvestmentAgent', back_populates='actions')
    
    def __repr__(self):
        return f'<AgentAction {self.action_type} for {self.ticker} by agent {self.agent_id}>'
    
    def to_dict(self):
        return {
            'id': self.id,
            'agent_id': self.agent_id,
            'action_type': self.action_type,
            'ticker': self.ticker,
            'action_data': self.action_data,
            'confidence_score': self.confidence_score,
            'risk_level': self.risk_level,
            'expected_return': self.expected_return,
            'execution_status': self.execution_status,
            'outcome_measured': self.outcome_measured,
            'actual_return': self.actual_return,
            'success': self.success,
            'created_at': self.created_at,
            'executed_at': self.executed_at
        }


class AgentRecommendation(db.Model):
    """Investment recommendations generated by AI agents"""
    __tablename__ = 'agent_recommendations'
    
    id = Column(Integer, primary_key=True)
    agent_id = Column(Integer, ForeignKey('investment_agents.id'), nullable=False)
    
    # Recommendation Details
    ticker = Column(String(20), nullable=False)
    recommendation_type = Column(String(20), nullable=False)  # 'BUY', 'SELL', 'HOLD', etc.
    target_price = Column(Float)
    current_price = Column(Float)
    
    # Confidence and Risk
    confidence_score = Column(Float, nullable=False)
    risk_level = Column(String(20), nullable=False)
    expected_return = Column(Float)
    time_horizon = Column(String(20))  # 'short_term', 'medium_term', 'long_term'
    
    # Analysis Factors
    reasoning = Column(JSON)  # Detailed reasoning for recommendation
    research_quality_score = Column(Float)
    analyst_track_record = Column(Float)
    market_conditions_score = Column(Float)
    technical_score = Column(Float)
    
    # Outcome Tracking
    status = Column(String(20), default='active')  # 'active', 'closed', 'expired'
    investor_response = Column(String(20))  # 'accepted', 'rejected', 'modified'
    outcome_return = Column(Float)
    outcome_success = Column(Boolean)
    
    # Source Information
    based_on_report_id = Column(String(50))  # Source research report
    analyst_name = Column(String(100))
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)
    expires_at = Column(DateTime)
    closed_at = Column(DateTime)
    
    # Relationships
    agent = relationship('InvestmentAgent', back_populates='recommendations')
    
    def __repr__(self):
        return f'<AgentRecommendation {self.recommendation_type} {self.ticker} by agent {self.agent_id}>'
    
    def to_dict(self):
        return {
            'id': self.id,
            'agent_id': self.agent_id,
            'ticker': self.ticker,
            'recommendation_type': self.recommendation_type,
            'target_price': self.target_price,
            'current_price': self.current_price,
            'confidence_score': self.confidence_score,
            'risk_level': self.risk_level,
            'expected_return': self.expected_return,
            'time_horizon': self.time_horizon,
            'reasoning': self.reasoning,
            'status': self.status,
            'investor_response': self.investor_response,
            'outcome_return': self.outcome_return,
            'outcome_success': self.outcome_success,
            'created_at': self.created_at,
            'expires_at': self.expires_at
        }


class AgentLearning(db.Model):
    """Learning data and patterns captured by AI agents"""
    __tablename__ = 'agent_learning'
    
    id = Column(Integer, primary_key=True)
    agent_id = Column(Integer, ForeignKey('investment_agents.id'), nullable=False)
    
    # Learning Pattern Information
    pattern_type = Column(String(50), nullable=False)  # 'success_pattern', 'failure_pattern', etc.
    pattern_data = Column(JSON, nullable=False)  # The actual pattern data
    
    # Context of Learning
    recommendation_id = Column(Integer, ForeignKey('agent_recommendations.id'))
    action_id = Column(Integer, ForeignKey('agent_actions.id'))
    
    # Pattern Effectiveness
    confidence_in_pattern = Column(Float, default=0.5)
    times_pattern_seen = Column(Integer, default=1)
    success_rate_with_pattern = Column(Float, default=0.0)
    
    # Learning Metadata
    learning_source = Column(String(50))  # 'outcome_analysis', 'market_feedback', etc.
    importance_score = Column(Float, default=0.5)  # How important this learning is
    
    # Applied Updates
    config_changes_applied = Column(JSON)  # What config changes resulted from this learning
    improvement_measured = Column(Float)  # Measured improvement from applying this learning
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)
    last_applied = Column(DateTime)
    
    # Relationships
    agent = relationship('InvestmentAgent', back_populates='learning_data')
    
    def __repr__(self):
        return f'<AgentLearning {self.pattern_type} for agent {self.agent_id}>'
    
    def to_dict(self):
        return {
            'id': self.id,
            'agent_id': self.agent_id,
            'pattern_type': self.pattern_type,
            'pattern_data': self.pattern_data,
            'confidence_in_pattern': self.confidence_in_pattern,
            'times_pattern_seen': self.times_pattern_seen,
            'success_rate_with_pattern': self.success_rate_with_pattern,
            'importance_score': self.importance_score,
            'config_changes_applied': self.config_changes_applied,
            'improvement_measured': self.improvement_measured,
            'created_at': self.created_at,
            'last_applied': self.last_applied
        }


class AgentAlert(db.Model):
    """Alerts generated by AI agents for investors"""
    __tablename__ = 'agent_alerts'
    
    id = Column(Integer, primary_key=True)
    agent_id = Column(Integer, ForeignKey('investment_agents.id'), nullable=False)
    
    # Alert Details
    alert_type = Column(String(50), nullable=False)  # 'market_event', 'portfolio_risk', 'opportunity', etc.
    severity = Column(String(20), nullable=False)  # 'LOW', 'MEDIUM', 'HIGH', 'CRITICAL'
    title = Column(String(200), nullable=False)
    message = Column(Text, nullable=False)
    
    # Alert Context
    ticker = Column(String(20))
    sector = Column(String(50))
    alert_data = Column(JSON)  # Additional alert-specific data
    
    # Action Required
    action_required = Column(Boolean, default=False)
    suggested_action = Column(String(100))
    urgency_level = Column(String(20), default='NORMAL')  # 'LOW', 'NORMAL', 'HIGH', 'IMMEDIATE'
    
    # Investor Response
    status = Column(String(20), default='active')  # 'active', 'read', 'acted_upon', 'dismissed'
    investor_response = Column(String(20))  # 'acknowledged', 'acted', 'ignored'
    response_time = Column(DateTime)
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)
    expires_at = Column(DateTime)
    
    def __repr__(self):
        return f'<AgentAlert {self.alert_type} - {self.severity} for agent {self.agent_id}>'
    
    def to_dict(self):
        return {
            'id': self.id,
            'agent_id': self.agent_id,
            'alert_type': self.alert_type,
            'severity': self.severity,
            'title': self.title,
            'message': self.message,
            'ticker': self.ticker,
            'sector': self.sector,
            'action_required': self.action_required,
            'suggested_action': self.suggested_action,
            'urgency_level': self.urgency_level,
            'status': self.status,
            'investor_response': self.investor_response,
            'created_at': self.created_at,
            'expires_at': self.expires_at
        }


class AgentPerformanceMetrics(db.Model):
    """Detailed performance metrics for AI agents"""
    __tablename__ = 'agent_performance_metrics'
    
    id = Column(Integer, primary_key=True)
    agent_id = Column(Integer, ForeignKey('investment_agents.id'), nullable=False)
    
    # Time Period
    metric_date = Column(DateTime, nullable=False)
    period_type = Column(String(20), nullable=False)  # 'daily', 'weekly', 'monthly'
    
    # Performance Metrics
    recommendations_made = Column(Integer, default=0)
    recommendations_successful = Column(Integer, default=0)
    accuracy_rate = Column(Float, default=0.0)
    
    # Return Metrics
    total_return = Column(Float, default=0.0)
    average_return_per_recommendation = Column(Float, default=0.0)
    best_performing_recommendation_return = Column(Float, default=0.0)
    worst_performing_recommendation_return = Column(Float, default=0.0)
    
    # Risk Metrics
    portfolio_volatility = Column(Float, default=0.0)
    sharpe_ratio = Column(Float, default=0.0)
    max_drawdown = Column(Float, default=0.0)
    
    # Behavioral Metrics
    response_time_avg = Column(Float, default=0.0)  # Average time to generate recommendations
    learning_iterations = Column(Integer, default=0)
    config_adjustments = Column(Integer, default=0)
    
    # Comparison Metrics
    vs_market_performance = Column(Float, default=0.0)
    vs_human_analyst_performance = Column(Float, default=0.0)
    investor_satisfaction_score = Column(Float, default=0.0)
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)
    
    def __repr__(self):
        return f'<AgentPerformanceMetrics for agent {self.agent_id} on {self.metric_date}>'
    
    def to_dict(self):
        return {
            'id': self.id,
            'agent_id': self.agent_id,
            'metric_date': self.metric_date,
            'period_type': self.period_type,
            'recommendations_made': self.recommendations_made,
            'recommendations_successful': self.recommendations_successful,
            'accuracy_rate': self.accuracy_rate,
            'total_return': self.total_return,
            'average_return_per_recommendation': self.average_return_per_recommendation,
            'portfolio_volatility': self.portfolio_volatility,
            'sharpe_ratio': self.sharpe_ratio,
            'vs_market_performance': self.vs_market_performance,
            'investor_satisfaction_score': self.investor_satisfaction_score,
            'created_at': self.created_at
        }


class AgentPortfolioTracking(db.Model):
    """Track portfolio positions influenced by AI agent recommendations"""
    __tablename__ = 'agent_portfolio_tracking'
    
    id = Column(Integer, primary_key=True)
    agent_id = Column(Integer, ForeignKey('investment_agents.id'), nullable=False)
    recommendation_id = Column(Integer, ForeignKey('agent_recommendations.id'))
    
    # Position Details
    ticker = Column(String(20), nullable=False)
    position_type = Column(String(10), nullable=False)  # 'LONG', 'SHORT'
    entry_price = Column(Float, nullable=False)
    exit_price = Column(Float)
    quantity = Column(Float, nullable=False)
    
    # Position Status
    status = Column(String(20), default='open')  # 'open', 'closed', 'partially_closed'
    entry_date = Column(DateTime, nullable=False)
    exit_date = Column(DateTime)
    
    # Performance
    unrealized_pnl = Column(Float, default=0.0)
    realized_pnl = Column(Float, default=0.0)
    return_percentage = Column(Float, default=0.0)
    
    # Risk Management
    stop_loss_price = Column(Float)
    take_profit_price = Column(Float)
    risk_amount = Column(Float)
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def __repr__(self):
        return f'<AgentPortfolioTracking {self.ticker} for agent {self.agent_id}>'
    
    def to_dict(self):
        return {
            'id': self.id,
            'agent_id': self.agent_id,
            'recommendation_id': self.recommendation_id,
            'ticker': self.ticker,
            'position_type': self.position_type,
            'entry_price': self.entry_price,
            'exit_price': self.exit_price,
            'quantity': self.quantity,
            'status': self.status,
            'unrealized_pnl': self.unrealized_pnl,
            'realized_pnl': self.realized_pnl,
            'return_percentage': self.return_percentage,
            'entry_date': self.entry_date,
            'exit_date': self.exit_date,
            'created_at': self.created_at
        }


# Helper functions for database operations
def create_agent_tables():
    """Create all agent-related tables"""
    try:
        db.create_all()
        print("Successfully created all agent tables")
        return True
    except Exception as e:
        print(f"Error creating agent tables: {e}")
        return False


def initialize_sample_agent(investor_id: str = "investor_001") -> InvestmentAgent:
    """Initialize a sample AI agent for testing"""
    
    # Check if agent already exists
    existing_agent = InvestmentAgent.query.filter_by(investor_id=investor_id).first()
    if existing_agent:
        print(f"Agent already exists for investor {investor_id}")
        return existing_agent
    
    # Create new agent
    sample_config = {
        'confidence_threshold': 0.7,
        'risk_tolerance': 0.5,
        'learning_rate': 0.1,
        'max_recommendations_per_day': 5,
        'quality_score_minimum': 0.6,
        'preferred_sectors': ['technology', 'banking', 'pharmaceuticals'],
        'investment_horizon': 'medium_term',
        'decision_weights': {
            'research_quality': 0.4,
            'analyst_track_record': 0.3,
            'market_conditions': 0.2,
            'risk_factors': 0.1
        }
    }
    
    agent = InvestmentAgent(
        investor_id=investor_id,
        agent_name=f"AI Investment Advisor for {investor_id}",
        config=sample_config
    )
    
    try:
        db.session.add(agent)
        db.session.commit()
        print(f"Successfully created sample agent for investor {investor_id}")
        return agent
    except Exception as e:
        db.session.rollback()
        print(f"Error creating sample agent: {e}")
        return None


def get_agent_summary_stats() -> Dict:
    """Get summary statistics for all agents"""
    try:
        total_agents = InvestmentAgent.query.count()
        active_agents = InvestmentAgent.query.filter_by(is_active=True).count()
        total_recommendations = db.session.query(db.func.sum(InvestmentAgent.total_recommendations)).scalar() or 0
        total_successful = db.session.query(db.func.sum(InvestmentAgent.successful_recommendations)).scalar() or 0
        
        overall_accuracy = (total_successful / total_recommendations * 100) if total_recommendations > 0 else 0
        
        return {
            'total_agents': total_agents,
            'active_agents': active_agents,
            'total_recommendations': total_recommendations,
            'successful_recommendations': total_successful,
            'overall_accuracy_rate': round(overall_accuracy, 2),
            'timestamp': datetime.utcnow()
        }
    except Exception as e:
        print(f"Error getting agent summary stats: {e}")
        return {}


if __name__ == "__main__":
    # This would be run when integrating with your main app
    print("Agentic AI Database Models loaded successfully!")
    print("\nTo integrate with your existing app:")
    print("1. Import these models in your app.py")
    print("2. Run db.create_all() to create the tables")
    print("3. Use initialize_sample_agent() to create test agents")
    print("\nExample usage:")
    print("from agentic_models import InvestmentAgent, AgentRecommendation")
    print("agent = initialize_sample_agent('investor_001')")
